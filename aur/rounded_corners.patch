diff --git a/.gitignore b/.gitignore
index cf5b826c2..fca4d7aad 100644
--- a/.gitignore
+++ b/.gitignore
@@ -1,5 +1,6 @@
 build-aux
 compile
+.vscode
 config.h
 config.h.in
 ltmain.sh
diff --git a/src/compositor/compositor.c b/src/compositor/compositor.c
index 1770550d4..e7142d5db 100644
--- a/src/compositor/compositor.c
+++ b/src/compositor/compositor.c
@@ -1022,7 +1022,11 @@ meta_compositor_sync_window_geometry (MetaCompositor *compositor,
   changes = meta_window_actor_sync_actor_geometry (window_actor, did_placement);
 
   if (changes & META_WINDOW_ACTOR_CHANGE_SIZE)
+  {
+    if (meta_window_actor_should_clip(window_actor))
+      meta_window_actor_update_clipped_bounds(window_actor);
     meta_plugin_manager_event_size_changed (priv->plugin_mgr, window_actor);
+  }
 }
 
 static void
diff --git a/src/compositor/meta-shadow-factory.c b/src/compositor/meta-shadow-factory.c
index d6424d3be..160e618c9 100644
--- a/src/compositor/meta-shadow-factory.c
+++ b/src/compositor/meta-shadow-factory.c
@@ -118,12 +118,12 @@ static guint signals[LAST_SIGNAL] = { 0 };
 /* The first element in this array also defines the default parameters
  * for newly created classes */
 MetaShadowClassInfo default_shadow_classes[] = {
-  { "normal",       { 10, -1, 0, 3, 128 }, { 8, -1, 0, 2, 64 } },
-  { "dialog",       { 10, -1, 0, 3, 128 }, { 8, -1, 0, 2, 64 } },
-  { "modal_dialog", { 10, -1, 0, 3, 128 }, { 8, -1, 0, 2, 64 } },
-  { "utility",      { 10, -1, 0, 3, 128 }, { 8, -1, 0, 2, 64 } },
-  { "border",       { 10, -1, 0, 3, 128 }, { 8, -1, 0, 2, 64 } },
-  { "menu",         { 10, -1, 0, 3, 128 }, { 8, -1, 0, 2, 64 } },
+  { "normal",       { 8, -1, 6, 6, 94 }, { 5, -1, 0, 2, 64 } },
+  { "dialog",       { 8, -1, 6, 6, 94 }, { 5, -1, 0, 2, 64 } },
+  { "modal_dialog", { 8, -1, 6, 6, 94 }, { 5, -1, 0, 2, 64 } },
+  { "utility",      { 8, -1, 6, 6, 94 }, { 5, -1, 0, 2, 64 } },
+  { "border",       { 8, -1, 6, 6, 94 }, { 5, -1, 0, 2, 64 } },
+  { "menu",         { 8, -1, 6, 6, 94 }, { 5, -1, 0, 2, 64 } },
 
   { "popup-menu",    { 1, -1, 0, 0, 128 }, { 1, -1, 0, 0, 128 } },
   { "dropdown-menu", { 1, -1, 0, 0, 128 }, { 1, -1, 0, 0, 128 } },
diff --git a/src/compositor/meta-window-actor-private.h b/src/compositor/meta-window-actor-private.h
index 64741e416..0f9c49c64 100644
--- a/src/compositor/meta-window-actor-private.h
+++ b/src/compositor/meta-window-actor-private.h
@@ -99,4 +99,7 @@ void meta_window_actor_update_regions (MetaWindowActor *self);
 
 gboolean meta_window_actor_can_freeze_commits (MetaWindowActor *self);
 
+gboolean meta_window_actor_should_clip(MetaWindowActor *self);
+void meta_window_actor_update_clipped_bounds(MetaWindowActor *window_actor);
+
 #endif /* META_WINDOW_ACTOR_PRIVATE_H */
diff --git a/src/compositor/meta-window-actor-x11.c b/src/compositor/meta-window-actor-x11.c
index e18b1b28b..f0469c77f 100644
--- a/src/compositor/meta-window-actor-x11.c
+++ b/src/compositor/meta-window-actor-x11.c
@@ -521,6 +521,9 @@ has_shadow (MetaWindowActorX11 *actor_x11)
       meta_window_is_fullscreen (window))
     return FALSE;
 
+  if (meta_window_actor_should_clip(META_WINDOW_ACTOR(actor_x11)))
+    return FALSE;
+
   /*
    * If we have two snap-tiled windows, we don't want the shadow to obstruct
    * the other window.
@@ -1236,9 +1239,12 @@ handle_updates (MetaWindowActorX11 *actor_x11)
       !meta_surface_actor_x11_is_visible (META_SURFACE_ACTOR_X11 (surface)))
     return;
 
-  update_frame_bounds (actor_x11);
   check_needs_reshape (actor_x11);
-  check_needs_shadow (actor_x11);
+  if (!meta_window_actor_should_clip(META_WINDOW_ACTOR(actor_x11)))
+  {
+    update_frame_bounds (actor_x11);
+    check_needs_shadow (actor_x11);
+  }
 }
 
 static void
@@ -1289,7 +1295,7 @@ meta_window_actor_x11_paint (ClutterActor        *actor,
   shadow = appears_focused ? actor_x11->focused_shadow
                            : actor_x11->unfocused_shadow;
 
-  if (shadow)
+  if (shadow && !meta_window_actor_should_clip(META_WINDOW_ACTOR(actor_x11)))
     {
       MetaShadowParams params;
       cairo_rectangle_int_t shape_bounds;
diff --git a/src/compositor/meta-window-actor.c b/src/compositor/meta-window-actor.c
index d4fc9a43a..77189e7fc 100644
--- a/src/compositor/meta-window-actor.c
+++ b/src/compositor/meta-window-actor.c
@@ -41,6 +41,109 @@
 #include "wayland/meta-wayland-surface.h"
 #endif
 
+#include "compositor/meta-surface-actor-x11.h"
+#include "meta/meta-shadow-factory.h"
+#include "ui/frames.h"
+
+/* 
+ * base on src/compositor/meta-background-content.c 
+ *
+ * The ellipsis_dist(), ellipsis_coverage() and rounded_rect_coverage() are
+ * copied from GSK, see gsk_ellipsis_dist(), gsk_ellipsis_coverage(), and
+ * gsk_rounded_rect_coverage() here:
+ * https://gitlab.gnome.org/GNOME/gtk/-/blob/master/gsk/resources/glsl/preamble.fs.glsl
+ */
+static gchar ROUNDED_CLIP_WINDOW_FRAGMENT_SHADER_CODE[] =  
+  "uniform sampler2D tex;                                                   \n"
+  "uniform int will_clip;                                                   \n"
+  "uniform vec4 bounds;           // x, y: top left; w, v: bottom right     \n"
+  "uniform vec4 corner_centers_1; // x, y: top left; w, v: top right        \n"
+  "uniform vec4 corner_centers_2; // x, y: bottom right; w, v: bottom left  \n"
+  "uniform vec2 pixel_step;                                                 \n"
+  "uniform float opacity;                                                   \n"
+  "                                                                         \n"
+  "float                                                                    \n"
+  "ellipsis_dist (vec2 p, vec2 radius)                                      \n"
+  "{                                                                        \n"
+  "  if (radius == vec2(0, 0))                                              \n"
+  "    return 0.0;                                                          \n"
+  "                                                                         \n"
+  "  vec2 p0 = p / radius;                                                  \n"
+  "  vec2 p1 = (2.0 * p0) / radius;                                         \n"
+  "                                                                         \n"
+  "  return (dot(p0, p0) - 1.0) / length (p1);                              \n"
+  "}                                                                        \n"
+  "                                                                         \n"
+  "float                                                                    \n"
+  "ellipsis_coverage (vec2 point, vec2 center, vec2 radius)                 \n"
+  "{                                                                        \n"
+  "  float d = ellipsis_dist ((point - center), radius);                    \n"
+  "  return clamp (0.5 - d, 0.0, 1.0);                                      \n"
+  "}                                                                        \n"
+  "                                                                         \n"
+  "float                                                                    \n"
+  "rounded_rect_coverage (vec4 bounds,                                      \n"
+  "                       vec4 corner_centers_1,                            \n"
+  "                       vec4 corner_centers_2,                            \n"
+  "                       vec2 p)                                           \n"
+  "{                                                                        \n"
+  "  if (p.x < bounds.x || p.y < bounds.y ||                                \n"
+  "      p.x >= bounds.z || p.y >= bounds.w)                                \n"
+  "    return 0.0;                                                          \n"
+  "                                                                         \n"
+  "  vec2 ref_tl = corner_centers_1.xy;                                     \n"
+  "  vec2 ref_tr = corner_centers_1.zw;                                     \n"
+  "  vec2 ref_br = corner_centers_2.xy;                                     \n"
+  "  vec2 ref_bl = corner_centers_2.zw;                                     \n"
+  "                                                                         \n"
+  "  if (p.x >= ref_tl.x && p.x >= ref_bl.x &&                              \n"
+  "      p.x <= ref_tr.x && p.x <= ref_br.x)                                \n"
+  "    return 1.0;                                                          \n"
+  "                                                                         \n"
+  "  if (p.y >= ref_tl.y && p.y >= ref_tr.y &&                              \n"
+  "      p.y <= ref_bl.y && p.y <= ref_br.y)                                \n"
+  "    return 1.0;                                                          \n"
+  "                                                                         \n"
+  "  vec2 rad_tl = corner_centers_1.xy - bounds.xy;                         \n"
+  "  vec2 rad_tr = corner_centers_1.zw - bounds.zy;                         \n"
+  "  vec2 rad_br = corner_centers_2.xy - bounds.zw;                         \n"
+  "  vec2 rad_bl = corner_centers_2.zw - bounds.xw;                         \n"
+  "                                                                         \n"
+  "  float d_tl = ellipsis_coverage(p, ref_tl, rad_tl);                     \n"
+  "  float d_tr = ellipsis_coverage(p, ref_tr, rad_tr);                     \n"
+  "  float d_br = ellipsis_coverage(p, ref_br, rad_br);                     \n"
+  "  float d_bl = ellipsis_coverage(p, ref_bl, rad_bl);                     \n"
+  "                                                                         \n"
+  "  vec4 corner_coverages = 1.0 - vec4(d_tl, d_tr, d_br, d_bl);            \n"
+  "                                                                         \n"
+  "  bvec4 is_out = bvec4(p.x < ref_tl.x && p.y < ref_tl.y,                 \n"
+  "                       p.x > ref_tr.x && p.y < ref_tr.y,                 \n"
+  "                       p.x > ref_br.x && p.y > ref_br.y,                 \n"
+  "                       p.x < ref_bl.x && p.y > ref_bl.y);                \n"
+  "                                                                         \n"
+  "  return 1.0 - dot(vec4(is_out), corner_coverages);                      \n"
+  "}                                                                        \n"
+  "                                                                         \n"
+  "void main()                                                              \n"
+  "{                                                                        \n"
+  "vec2 texture_coord;                                                      \n"
+  "                                                                         \n"
+  "  texture_coord = cogl_tex_coord0_in.xy / pixel_step;                    \n"
+  "  vec4 res;                                                              \n"
+  "  if (will_clip == 1) {                                                  \n"
+  // "    res =  (texture2D(tex, cogl_tex_coord0_in.xy) + vec4(0.2, 0.2, 0.2, 0.2))                         \n"
+  "    res =  texture2D(tex, cogl_tex_coord0_in.xy)                         \n"
+  "                   *  rounded_rect_coverage(bounds,                      \n"
+  "                                            corner_centers_1,            \n"
+  "                                            corner_centers_2,            \n"
+  "                                            texture_coord);              \n"
+  "  } else {                                                               \n"
+  "      res =  texture2D(tex, cogl_tex_coord0_in.xy);                      \n"
+  "  }                                                                      \n"
+  "  res *= opacity;                                                        \n"
+  "  cogl_color_out = res;                                                  \n"
+  "}";
+
 typedef enum
 {
   INITIALLY_FROZEN,
@@ -55,6 +158,24 @@ typedef struct _MetaWindowActorPrivate
 
   MetaSurfaceActor *surface;
 
+  ClutterShaderEffect *round_clip_effect;
+  gboolean effect_setuped;
+
+  // shadow for rounded clipped window
+  // copied from meta-window-actor-x11.c
+  MetaShadow *focused_shadow;
+  MetaShadow *unfocused_shadow;
+  MetaShadowFactory *shadow_factory;
+  /* A region that matches the shape of the window, including frame bounds */
+  cairo_region_t *shape_region;
+  /* The frame region */
+  cairo_region_t *frame_bounds;
+  /* The region we should clip to when painting the shadow */
+  cairo_region_t *shadow_clip;
+  gboolean recompute_focused_shadow;
+  gboolean recompute_unfocused_shadow;
+  MetaWindowShape *shadow_shape;
+
   int geometry_scale;
 
   /*
@@ -119,12 +240,439 @@ G_DEFINE_ABSTRACT_TYPE_WITH_CODE (MetaWindowActor, meta_window_actor, CLUTTER_TY
                                   G_IMPLEMENT_INTERFACE (META_TYPE_CULLABLE, cullable_iface_init)
                                   G_IMPLEMENT_INTERFACE (META_TYPE_SCREEN_CAST_WINDOW, screen_cast_window_iface_init));
 
+// config
+typedef struct {
+  guint radius        ;
+  guint inner_left    ;
+  guint inner_top     ;
+  guint inner_right   ;
+  guint inner_bottom  ; 
+} RoundedCornerConfig;
+
+static RoundedCornerConfig ROUNDED_CORNER_CONFIG = {
+  .radius = 30,
+  .inner_left = 0,
+  .inner_top  = 0,
+  .inner_left = 0,
+  .inner_left = 0,
+};
+
+static ClutterShaderEffect*
+create_clip_effect(void)
+{
+  ClutterShaderEffect *effect=
+    CLUTTER_SHADER_EFFECT(clutter_shader_effect_new(CLUTTER_FRAGMENT_SHADER));
+  if (!clutter_shader_effect_set_shader_source(effect,
+                                               ROUNDED_CLIP_WINDOW_FRAGMENT_SHADER_CODE))
+  {
+    g_clear_object(&effect);
+  }
+  
+  clutter_shader_effect_set_uniform(effect, "tex", G_TYPE_INT, 1, 0);
+  return effect;
+}
+
+static void
+check_meta_window_surface_actor(MetaWindowActor *self)
+{
+  MetaWindowActorPrivate *priv = meta_window_actor_get_instance_private(self);
+  MetaSurfaceActor *surface = meta_window_actor_get_surface(self);
+
+  if (!priv->effect_setuped && surface && priv->round_clip_effect)
+  {
+    clutter_actor_add_effect_with_name(CLUTTER_ACTOR(surface),
+                                       "Rounded Corners Effect(Surface)",
+                                       CLUTTER_EFFECT(priv->round_clip_effect));
+    priv->effect_setuped = true;
+  }
+}
+
+static void
+get_rounded_corner_bounds(MetaWindowActor *self,
+                          float *x1, float *y1, float *x2, float *y2)
+{
+  MetaRectangle frame_rect;
+  MetaRectangle buf_rect;
+  MetaWindow *window = meta_window_actor_get_meta_window(self);
+
+  meta_window_get_frame_rect(window, &frame_rect);
+  meta_window_get_buffer_rect(window, &buf_rect);
+
+  float offset_x = frame_rect.x - buf_rect.x;
+  float offset_y = frame_rect.y - buf_rect.y;
+
+  *x1 = offset_x + ROUNDED_CORNER_CONFIG.inner_left + 1.0f;
+  *y1 = offset_y + ROUNDED_CORNER_CONFIG.inner_top  + 1.0f;
+  *x2 = offset_x + frame_rect.width - ROUNDED_CORNER_CONFIG.inner_right;
+  *y2 = offset_y + frame_rect.height - ROUNDED_CORNER_CONFIG.inner_bottom;
+}
+
+static void
+meta_window_actor_setup_glsl(MetaWindowActor *self)
+{
+  MetaWindowActorPrivate *priv = meta_window_actor_get_instance_private (self);
+  ClutterShaderEffect *effect = priv->round_clip_effect;
+  ClutterActor *actor = CLUTTER_ACTOR(priv->surface);
+
+  check_meta_window_surface_actor(self);
+  
+  clutter_shader_effect_set_uniform(effect,"opacity",
+                                    G_TYPE_FLOAT, 1,
+                                    clutter_actor_get_opacity(actor) / 255.0f);
+
+  if (!meta_window_actor_should_clip(self)) 
+  {
+    clutter_shader_effect_set_uniform(effect, "will_clip", G_TYPE_INT, 1, 0);
+    return ;
+  }
+
+  float x1, y1, x2, y2, w, h;
+  const uint r = ROUNDED_CORNER_CONFIG.radius;
+  get_rounded_corner_bounds(self, &x1, &y1, &x2, &y2);
+  clutter_actor_get_size(actor, &w, &h);
+
+  clutter_shader_effect_set_uniform(effect, "will_clip", G_TYPE_INT, 1, 1);
+  clutter_shader_effect_set_uniform(effect, "bounds", G_TYPE_FLOAT,
+                                    4, x1, y1, x2, y2);
+  clutter_shader_effect_set_uniform(effect, "corner_centers_1", G_TYPE_FLOAT,
+                                    4, x1 + r, y1 + r, x2 - r, y1 + r);
+  clutter_shader_effect_set_uniform(effect, "corner_centers_2", G_TYPE_FLOAT, 
+                                    4, x2 - r, y2 - r, x1 + r, y2 - r);
+  clutter_shader_effect_set_uniform(effect, "pixel_step", G_TYPE_FLOAT,
+                                    2, 1. / w, 1. / h);
+}
+
+gboolean
+meta_window_actor_should_clip(MetaWindowActor *self)
+{
+  MetaWindowActorPrivate *priv = meta_window_actor_get_instance_private (self);
+  MetaWindow *window = priv->window;
+  MetaWindowType window_type = meta_window_get_window_type(window);
+
+  return !(
+    window_type == META_WINDOW_DOCK ||
+    window_type == META_WINDOW_POPUP_MENU ||
+    window_type == META_WINDOW_DROPDOWN_MENU ||
+    window_type == META_WINDOW_OVERRIDE_OTHER ||
+    window_type == META_WINDOW_TOOLTIP ||
+    meta_window_get_maximized(window) ||
+    meta_window_is_fullscreen(window)
+  );
+}
+
+static cairo_region_t * 
+get_bounds_clipped (const MetaRectangle *bounds,
+                    float radius)
+{
+  MetaFrameGeometry fgeom;
+ 
+  fgeom.borders.invisible.left = bounds->x;
+  fgeom.borders.invisible.top =  bounds->y;
+  fgeom.borders.invisible.bottom = 0;
+  fgeom.borders.invisible.right =  0;
+  fgeom.width  = bounds->width + bounds->x;
+  fgeom.height = bounds->height + bounds->y;
+
+  fgeom.top_left_corner_rounded_radius = radius;
+  fgeom.top_right_corner_rounded_radius = radius;
+  fgeom.bottom_left_corner_rounded_radius = radius;
+  fgeom.bottom_right_corner_rounded_radius = radius;
+  
+  return get_visible_region (NULL, &fgeom);
+}
+
+static cairo_region_t *
+meta_window_get_clipped_frame_bounds(MetaWindow *window)
+{
+  if (!window->frame_bounds)
+  {
+    MetaRectangle frame_rect = window->rect;
+    MetaRectangle buff_rect = window->buffer_rect;
+    frame_rect.x = frame_rect.x - buff_rect.x;
+    frame_rect.y = frame_rect.y - buff_rect.y;
+    window->frame_bounds = get_bounds_clipped(&frame_rect, ROUNDED_CORNER_CONFIG.radius);
+  }
+  return window->frame_bounds;
+}
+
+static void
+update_frame_bounds (MetaWindowActor *actor)
+{
+  g_return_if_fail(meta_window_actor_should_clip(actor));
+
+  MetaWindow *window = meta_window_actor_get_meta_window (actor);
+  MetaWindowActorPrivate *priv = meta_window_actor_get_instance_private(actor);
+
+  g_clear_pointer(&priv->frame_bounds, cairo_region_destroy);
+  priv->frame_bounds = cairo_region_copy(meta_window_get_clipped_frame_bounds(window));
+}
+
+// copied from meta-window-actor-x11.c
+// for paint shadow for round clipped window
+static const char *
+get_shadow_class (MetaWindowActor *actor)
+{  
+  MetaWindow *window =
+    meta_window_actor_get_meta_window (actor);
+  MetaWindowType window_type;
+
+  window_type = meta_window_get_window_type (window);
+  switch (window_type)
+    {
+    case META_WINDOW_DROPDOWN_MENU:
+    case META_WINDOW_COMBO:
+      return "dropdown-menu";
+    case META_WINDOW_POPUP_MENU:
+      return "popup-menu";
+    default:
+      {
+        MetaFrameType frame_type;
+
+        frame_type = meta_window_get_frame_type (window);
+        return meta_frame_type_to_string (frame_type);
+      }
+    }
+}
+
+// copied from meta-window-actor-x11.c
+// for paint shadow for round clipped window
+static void
+get_shape_bounds (MetaWindowActor    *actor,
+                  cairo_rectangle_int_t *bounds)
+{
+  MetaWindowActorPrivate *priv = meta_window_actor_get_instance_private(actor);
+
+  cairo_region_get_extents (priv->shape_region, bounds);
+}
+
+// copied from meta-window-actor-x11.c
+// for paint shadow for round clipped window
+static void
+check_needs_shadow (MetaWindowActor *actor)
+{
+  MetaWindow *window =
+    meta_window_actor_get_meta_window (META_WINDOW_ACTOR (actor));
+  MetaWindowActorPrivate *priv = meta_window_actor_get_instance_private(actor);
+  MetaShadow *old_shadow = NULL;
+  MetaShadow **shadow_location;
+  gboolean recompute_shadow;
+  gboolean should_have_shadow;
+  gboolean appears_focused;
+
+  should_have_shadow = TRUE;
+  appears_focused = meta_window_appears_focused (window);
+
+  if (appears_focused)
+    {
+      recompute_shadow = priv->recompute_focused_shadow;
+      priv->recompute_focused_shadow = FALSE;
+      shadow_location = &priv->focused_shadow;
+    }
+  else
+    {
+      recompute_shadow = priv->recompute_unfocused_shadow;
+      priv->recompute_unfocused_shadow = FALSE;
+      shadow_location = &priv->unfocused_shadow;
+    }
+
+  if (!should_have_shadow || recompute_shadow)
+    {
+      if (*shadow_location != NULL)
+        {
+          old_shadow = *shadow_location;
+          *shadow_location = NULL;
+        }
+    }
+
+  if (!*shadow_location && should_have_shadow)
+    {
+      MetaShadowFactory *factory = priv->shadow_factory;
+      const char *shadow_class = get_shadow_class (actor);
+      cairo_rectangle_int_t shape_bounds;
+
+      if (!priv->shadow_shape)
+        {
+          priv->shadow_shape =
+            meta_window_shape_new (priv->shape_region);
+        }
+
+      get_shape_bounds (actor, &shape_bounds);
+      *shadow_location =
+        meta_shadow_factory_get_shadow (factory,
+                                        priv->shadow_shape,
+                                        shape_bounds.width, shape_bounds.height,
+                                        shadow_class, appears_focused);
+    }
+
+  if (old_shadow)
+    meta_shadow_unref (old_shadow);
+}
+
+// copied from meta-window-actor-x11.c
+// for paint shadow for round clipped window
+static void
+get_shadow_params (MetaWindowActor    *actor,
+                   gboolean            appears_focused,
+                   MetaShadowParams   *params)
+{
+  const char *shadow_class = get_shadow_class (actor);
+  MetaWindowActorPrivate *priv = meta_window_actor_get_instance_private(actor);
+
+  meta_shadow_factory_get_params (priv->shadow_factory,
+                                  shadow_class, appears_focused,
+                                  params);
+}
+
+
+// copied from meta-window-actor-x11.c
+// for paint shadow for round clipped window
+static void
+get_shadow_bounds (MetaWindowActor *actor,
+                   gboolean               appears_focused,
+                   cairo_rectangle_int_t *bounds)
+{
+  MetaShadow *shadow;
+  cairo_rectangle_int_t shape_bounds;
+  MetaShadowParams params;
+  MetaWindowActorPrivate *priv = meta_window_actor_get_instance_private(actor);
+
+
+  shadow = appears_focused ? priv->focused_shadow
+                           : priv->unfocused_shadow;
+
+  get_shape_bounds  (actor, &shape_bounds);
+  get_shadow_params (actor, appears_focused, &params);
+
+  meta_shadow_get_bounds (shadow,
+                          params.x_offset + shape_bounds.x,
+                          params.y_offset + shape_bounds.y,
+                          shape_bounds.width,
+                          shape_bounds.height,
+                          bounds);
+}
+
+// copied from meta-window-actor-x11.c
+// for paint shadow for round clipped window
+static void
+invalidate_shadow (MetaWindowActor *actor)
+{
+  MetaWindowActorPrivate *priv = meta_window_actor_get_instance_private(actor);
+
+  priv->recompute_focused_shadow = TRUE;
+  priv->recompute_unfocused_shadow = TRUE;
+
+  if (meta_window_actor_is_frozen (META_WINDOW_ACTOR (actor)))
+    return;
+
+  clutter_actor_queue_redraw (CLUTTER_ACTOR (actor));
+  clutter_actor_invalidate_paint_volume (CLUTTER_ACTOR (actor));
+}
+
+// copied from meta-window-actor-x11.c
+// for paint shadow for round clipped window
+static void
+update_shape_region (MetaWindowActor *actor)
+{
+  MetaWindow *window =
+    meta_window_actor_get_meta_window (META_WINDOW_ACTOR (actor));
+  MetaWindowActorPrivate *priv = meta_window_actor_get_instance_private(actor);
+
+  cairo_region_t *region = cairo_region_copy(meta_window_get_clipped_frame_bounds(window));
+
+  g_clear_pointer (&priv->shadow_shape, meta_window_shape_unref);
+  priv->shape_region = region;
+
+  invalidate_shadow (actor);
+}
+
+// copied from meta-window-actor-x11.c
+// for paint shadow for round clipped window
+static void
+meta_window_actor_paint (ClutterActor        *actor,
+                         ClutterPaintContext *paint_context)
+{
+  MetaWindowActor *window_actor = META_WINDOW_ACTOR(actor);
+  MetaWindowActorPrivate *priv =
+    meta_window_actor_get_instance_private(window_actor);
+  MetaWindow *window;
+  gboolean appears_focused;
+  MetaShadow *shadow;
+
+  window = meta_window_actor_get_meta_window (window_actor);
+  appears_focused = meta_window_appears_focused (window);
+  shadow = appears_focused ? priv->focused_shadow
+                           : priv->unfocused_shadow;
+                                                                   
+  if (shadow && meta_window_actor_should_clip(actor))
+    {
+      MetaShadowParams params;
+      cairo_rectangle_int_t shape_bounds;
+      cairo_region_t *clip = priv->shadow_clip;
+      CoglFramebuffer *framebuffer;
+
+      get_shadow_params (window_actor , appears_focused, &params);
+
+      MetaRectangle frame_rect;
+      MetaRectangle buf_rect;
+      cairo_rectangle_int_t bounds;
+
+      meta_window_get_frame_rect( META_WINDOW(window), &frame_rect);
+      meta_window_get_buffer_rect(META_WINDOW(window), &buf_rect);
+      shape_bounds.x = frame_rect.x - buf_rect.x;
+      shape_bounds.y = frame_rect.y - buf_rect.y;
+      shape_bounds.width = frame_rect.width;
+      shape_bounds.height = frame_rect.height;
+
+      get_shadow_bounds (window_actor, appears_focused, &bounds);
+
+      clip = cairo_region_create_rectangle (&bounds);
+      if (priv->frame_bounds)
+        cairo_region_subtract (clip, priv->frame_bounds);
+
+      framebuffer = clutter_paint_context_get_framebuffer (paint_context);
+      meta_shadow_paint (shadow,
+                         framebuffer,
+                         params.x_offset + shape_bounds.x,
+                         params.y_offset + shape_bounds.y,
+                         shape_bounds.width,
+                         shape_bounds.height,
+                         (clutter_actor_get_paint_opacity (actor) *
+                          params.opacity * window->opacity) / (255 * 255),
+                         clip,
+                         TRUE);
+
+      if (clip)
+        cairo_region_destroy (clip);
+    }
+
+  meta_window_actor_setup_glsl(window_actor);
+  
+  CLUTTER_ACTOR_CLASS (meta_window_actor_parent_class)->paint (actor,
+                                                               paint_context);
+}
+
+void
+meta_window_actor_update_clipped_bounds(MetaWindowActor *window_actor)
+{
+  MetaWindowActorPrivate *priv =
+    meta_window_actor_get_instance_private(window_actor);
+  MetaWindow *window = priv->window;
+
+  if (window->frame_bounds) {
+    cairo_region_destroy(window->frame_bounds);
+    window->frame_bounds = NULL;
+  }
+}
+
 static void
 meta_window_actor_class_init (MetaWindowActorClass *klass)
 {
   GObjectClass *object_class = G_OBJECT_CLASS (klass);
   GParamSpec   *pspec;
 
+  ClutterActorClass *actor_class = CLUTTER_ACTOR_CLASS (klass);
+  actor_class->paint = meta_window_actor_paint;
+
   object_class->dispose      = meta_window_actor_dispose;
   object_class->set_property = meta_window_actor_set_property;
   object_class->get_property = meta_window_actor_get_property;
@@ -216,6 +764,10 @@ meta_window_actor_init (MetaWindowActor *self)
     meta_window_actor_get_instance_private (self);
 
   priv->geometry_scale = 1;
+  priv->round_clip_effect = create_clip_effect();
+  priv->effect_setuped = FALSE;
+
+  priv->shadow_factory = meta_shadow_factory_get_default();
 }
 
 static void
@@ -453,6 +1005,12 @@ meta_window_actor_dispose (GObject *object)
       g_clear_object (&priv->surface);
     }
 
+  g_clear_pointer (&priv->shape_region, cairo_region_destroy);
+  g_clear_pointer (&priv->frame_bounds, cairo_region_destroy);
+  g_clear_pointer (&priv->focused_shadow, meta_shadow_unref);
+  g_clear_pointer (&priv->unfocused_shadow, meta_shadow_unref);
+  g_clear_pointer (&priv->shadow_shape, meta_window_shape_unref);
+
   G_OBJECT_CLASS (meta_window_actor_parent_class)->dispose (object);
 }
 
@@ -1046,6 +1604,13 @@ meta_window_actor_before_paint (MetaWindowActor  *self,
     return;
 
   META_WINDOW_ACTOR_GET_CLASS (self)->before_paint (self, stage_view);
+
+  if (meta_window_actor_should_clip(self))
+  {
+    update_frame_bounds(self);
+    update_shape_region(self);
+    check_needs_shadow(self);
+  }
 }
 
 void
diff --git a/src/ui/frames.c b/src/ui/frames.c
index 48b2a361c..2d10ffcc6 100644
--- a/src/ui/frames.c
+++ b/src/ui/frames.c
@@ -612,7 +612,7 @@ get_visible_frame_rect (MetaFrameGeometry     *fgeom,
   rect->height = fgeom->height - fgeom->borders.invisible.bottom - rect->y;
 }
 
-static cairo_region_t *
+cairo_region_t *
 get_visible_region (MetaUIFrame       *frame,
                     MetaFrameGeometry *fgeom)
 {
diff --git a/src/ui/frames.h b/src/ui/frames.h
index 73dee1737..24da015ad 100644
--- a/src/ui/frames.h
+++ b/src/ui/frames.h
@@ -146,4 +146,9 @@ void meta_ui_frame_queue_draw (MetaUIFrame *frame);
 
 gboolean meta_ui_frame_handle_event (MetaUIFrame *frame, const ClutterEvent *event);
 
+// will be used to clip shadow of rounded corners window
+cairo_region_t *
+get_visible_region (MetaUIFrame       *frame,
+                    MetaFrameGeometry *fgeom);
+
 #endif
